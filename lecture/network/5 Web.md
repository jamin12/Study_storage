## DNS란

DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환해주는 시스템입니다.
우리는 www.naver.com 같은 도메인을 입력하지만, 컴퓨터는 오직 숫자인 IP 주소(예: 223.130.195.200)로 통신하기 때문에, 이 둘 사이를 이어주는 번역기가 바로 DNS입니다.

핵심 역할:
- 도메인 → IP 주소 변환
- 인터넷의 전화번호부
- TCP/IP 통신의 출발점

### **1. 분산형 구조**

DNS는 전 세계의 수십억 개 도메인을 처리해야 하므로, 하나의 서버가 모든 정보를 갖고 있을 수 없습니다.
그래서 DNS는 **계층적이고 분산된 구조**로 이루어져 있으며, 각 레벨이 특정 역할을 나눠서 처리합니다.

DNS는 트리 형태의 구조를 가짐:
- .com → 최상위 도메인 (TLD)
- naver → Second-level 도메인
- www → 호스트 이름 

각 도메인 영역(zone)은 독립적으로 관리되고, 정보는 분산된 네임서버들에 의해 유지됩니다.
#### **Zone이란?**

> **Zone**은 DNS에서 **하나의 네임서버 세트가 책임지고 관리하는 도메인 영역**입니다.
> 즉, DNS 레코드들이 실제로 **저장되고 응답되는 범위**예요.

- Zone은 “도메인 이름 공간”의 **데이터 저장 단위**
-  A, CNAME, MX, NS 같은 **레코드들이 저장된 범위**
- **관리자(네임서버)의 책임 범위**라고 생각하면 됩니다

| **구성 요소** | **용어**           | **예시**          |
| --------- | ---------------- | --------------- |
| 최상위 도메인   | TLD              | .com, .net, .kr |
| 도메인 이름    | Domain           | test.com        |
| 서브도메인     | Subdomain / Host | www, blog, mail |
| 전체 주소     | 정규화 도메인 이름       | www.test.com    |

### 2. DNS 흐름

사용자가 브라우저에 www.naver.com을 입력하면 다음과 같은 단계로 DNS 질의가 진행됩니다.
1. PC는 **로컬 DNS 캐시**에서 먼저 확인
2. 캐시에 없으면 **ISP DNS 서버**에 질의
3. ISP DNS도 없으면 → **Root DNS**에 질의
4. Root DNS → .com을 관리하는 **TLD DNS** 주소 반환
5. .com TLD DNS → naver.com을 관리하는 **네임서버(NS)** 반환
6. NS → www.naver.com의 IP 주소 반환
7. IP 주소를 받아 웹서버에 접속
  
요약하면: **로컬 캐시 → ISP DNS → Root → TLD → NS → 최종 IP**

### 3. DNS 캐시

DNS 응답 결과는 반복적으로 사용되는 경우가 많기 때문에, **캐시(Cache)** 를 통해 처리 속도를 빠르게 합니다.
운영체제, 브라우저, ISP DNS 모두 캐시를 보관하며, 일정 시간(TTL) 동안은 재질의 없이 그대로 사용합니다.
- PC에서는 ipconfig /displaydns로 확인 가능
    
- TTL이 만료되면 다시 DNS에게 질의함

### 4. hosts 파일

Windows 등 운영체제에는 hosts 파일이라는 것이 존재합니다.
이 파일에는 특정 도메인에 대응되는 IP 주소를 수동으로 지정할 수 있으며, DNS보다 우선됩니다.

- 보안 프로그램이 hosts 파일을 보호하는 이유
    
- 과거에는 악성코드가 이 파일을 조작해 피싱 사이트로 유도하기도 함

### 5. DNS 해킹

DNS는 인터넷 보안의 첫 관문입니다.
만약 DNS 서버가 공격을 받아 잘못된 IP 주소를 응답하면, 사용자는 정상적인 도메인 이름을 입력했음에도 피싱 사이트로 접속하게 될 수 있습니다.

이런 공격을 **DNS 스푸핑** 또는 **캐시 포이즈닝**이라고 합니다.
이를 방지하기 위해 DNSSEC 같은 보안 프로토콜도 도입되고 있습니다.

### **6. 도메인을 구매**

 test.com이라는 도메인을 가비아에서 구매했다고 가정해 합니다.
그 순간 DNS 세계에서는 다음과 같은 절차가 일어납니다.

도메인 등록 과정:
1. 가비아(Registrar)는 .com을 관리하는 **Verisign(Registry)** 에 등록 요청
2. Verisign은 .com TLD DNS에 다음 정보 저장:
    - 도메인 이름: test.com
    - 관리 네임서버(NS): ns1.gabia.co.kr
3. 가비아는 Authoritative DNS인 NS 서버에 다음 정보 등록:
    - A 레코드: www.test.com → 123.123.123.123
    - MX, CNAME 등 부가 정보


### 7. 이후접속
1. 사용자가 주소창에 www.test.com 입력
2. 브라우저는 DNS 질의 시작
3. 캐시 없을 경우 → Root → .com TLD → ns1.gabia.co.kr 순으로 따라감
4. gabia 네임서버에서 IP 주소 응답 → 웹서버 접속

- **TLD DNS는 NS 정보만 알고 있음**
- **실제 IP는 Authoritative DNS(NS 서버)가 알고 있음**
- **Root DNS는 오직 TLD들의 위치만 알고 있음**


```mermaid
flowchart TD

%% 단계 1: 도메인 구매 및 등록
A["도메인 등록 사이트(가비아 등)에서 test.com 도메인 구매"] --> B["가비아는 .com Registry(Verisign)에 도메인 등록 요청"]
B --> C["Verisign은 test.com → ns1.gabia.co.kr로 NS 정보 저장 (TLD DNS)"]

%% 단계 2: 네임서버 설정
C --> D["가비아는 ns1.gabia.co.kr에 test.com의 A/CNAME/MX 등 DNS 레코드 설정"]

%% 단계 3: 사용자가 www.test.com 접속 시
E["사용자가 브라우저에 url 입력"] --> F["PC는 로컬 DNS(예: ISP DNS)에 질의"]
F --> G{"로컬 DNS에 캐시 있음?"}
G -- Yes --> H["캐시된 IP 주소로 바로 응답"]
G -- No --> I["Root DNS 서버에 질의 → .com TLD 주소 요청"]
I --> J[".com TLD DNS 서버(Verisign)로부터 test.com의 NS 정보 획득"]
J --> K["ns1.gabia.co.kr로 url의 IP 주소 요청"]
K --> L["Authoritative DNS(gabia)에서 최종 IP 주소 응답"]
L --> M["로컬 DNS는 응답 결과를 캐시에 저장"]
M --> N["PC에 최종 IP 주소 응답"]
N --> O["브라우저가 해당 IP 주소로 HTTP 요청 → 접속 완료"]
```

---
## 웹 기술의 창시자


웹의 시초는 **유럽 입자물리연구소(CERN)** 에서 시작됩니다.
바로 이곳에서 컨설턴트로 근무하던 **팀 버너스리(Tim Berners-Lee)** 가
웹의 핵심 기술들을 창안하게 되었죠.

- 입자물리연구소에서 **정보검색 시스템 구축**
- 연구원들이 **논문을 참고문헌 기반으로 계속 넘나들며** 정보를 찾는 걸 보며,
    → “문서 간 연결이 자연스러우면 좋겠다”는 문제의식을 가짐
- 그래서 고안한 것이 바로 **HTML**
    → 문서에서 링크를 클릭해 다른 문서로 이동할 수 있는 **하이퍼텍스트 개념**을 구현

> 팀 버너스리는 문서를 연결하는 기술(HTML)을 만들었고,
> 그것을 인터넷 위에서 전달하기 위한 방법(HTTP)을 설계했습니다.

결국에는  파일을 쉽고 연결성 있게 보기 위한 목적에 만들어졌다.

---
## URL과 URI

### 1. URI와 URL의 차이

- **URI(Uniform Resource Identifier)**
    → **자원을 식별**하는 “이름표”입니다.
- **URL(Uniform Resource Locator)**
    → 그 중에서도 **자원이 위치한 경로를 가리키는 것**, 즉 “주소”입니다.

> 모든 URL은 URI다. 하지만 모든 URI가 URL인 것은 아니다.

### **2. Resource**

웹에서 리소스(Resource)는 결국 **파일**입니다.
대표적으로는 HTML 파일이 있지만,
- HTML 문서
- CSS 파일
- JavaScript 파일
- 이미지(jpg, png 등)
- 데이터 (JSON, XML 등)
- 서버 내부의 API 결과
도 파일에 해당한다.

### 3. URI 구조

```
scheme ":" ["//" authority] path ["?" query] ["#" fragment]

쉽게 바꿨을 때
Protocol://Address:port/path?parameter=value
```

| **구성 요소**     | **의미**              | **예시**                          |
| ------------- | ------------------- | ------------------------------- |
| **scheme**    | 어떤 프로토콜로 접근할지       | http, https, ftp                |
| **authority** | 접속 대상 주소 (도메인 + 포트) | www.test.co.kr:80               |
| **path**      | 서버 내의 자원 경로         | /course.do                      |
| **query**     | 요청 파라미터             | ?cmd=search&search_keyword=Test |
| **fragment**  | 문서 내 특정 위치          | #section1                       |
### **4. URI의 경로(path)는 ‘파일 경로’다**

  이 path는 웹 서버에서 실제 파일이 위치한 경로를 의미합니다.

- 브라우저에서 http://www.test.co.kr/을 입력하면
    실제로는 http://www.test.co.kr/index.html을 요청한 것과 같습니다.
- 이 파일은 서버에서 /root/data/index.html 같은 절대경로에 있을 수 있습니다.
- 그러나 사용자는 주소창에 전체 경로를 쓰지 않고도 접속 가능하죠.
    → 이는 서버가 기준 디렉터리를 정해두고, **상대 경로**로 응답하기 때문입니다.

### **5. 쿼리 파라미터(Query Parameter)의 사용**

URI 뒤에 붙는 ?key=value 형식은 서버에 전달할 **데이터 요청 조건**입니다.


> URL = **식별 + 위치 정보**
> URI = **식별**
> 그리고 그 자원(resource)은 결국 HTML, 이미지, API 응답 같은 **웹 상의 파일들** 입니다.

---
## **HTTP**
**HTTP** 는 **HTML 문서를 전송하기 위해 만들어진 애플리케이션 계층의 통신 프로토콜**입니다.

- 1996년: HTTP/1.0 등장
- 1999년 6월: HTTP/1.1 정식 발표
- 클라이언트-서버 모델 기반의 **요청/응답 구조**

HTML뿐만 아니라 이미지, JSON, CSS, JS 등 **웹 리소스 전반을 전송**하는 데 사용됩니다.


### **1. HTTP의 기본 구조**

HTTP는 TCP 위에서 동작하며,
**L7 계층의 텍스트 기반 프로토콜**입니다.
즉, **모든 메시지가 문자열**로 표현되어 이해하기 쉽습니다.
- 요청(request) → 서버로 문서 요청
- 응답(response) → 서버가 문서 반환

요청과 응답 모두 **HTTP 메시지 형식**으로 구성됨
핵심은 **Header + Body**의 구조

### **2. HTTP 메서드 (Method)**

  클라이언트가 서버에 “무엇을 하길 원하는지”를 나타내는 방식입니다.

| **메서드**     | **설명**                            |
| ----------- | --------------------------------- |
| **GET**     | 서버에 데이터 요청 (다운로드 개념)              |
| **POST**    | 서버에 데이터 전송 (업로드 개념, 예: 로그인, 회원가입) |
| **PUT**     | 자원 전체를 업데이트                       |
| **DELETE**  | 자원 삭제 요청                          |
| **HEAD**    | GET과 유사하지만 본문 없이 헤더만 요청           |
| **OPTIONS** | 지원 가능한 메서드 조회                     |
| **CONNECT** | 프록시 터널 생성                         |
| **TRACE**   | 경로 추적 요청                          |

### **3. HTTP 요청의 구조**

요청은 다음과 같은 정보들을 헤더에 포함합니다:

| **필드**              | **설명**                        |
| ------------------- | ----------------------------- |
| **Request URL**     | 요청 대상의 경로 (예: /)              |
| **HTTP Version**    | 사용 중인 HTTP 버전 (예: HTTP/1.1)   |
| **Host**            | 요청 대상의 도메인 (예: www.naver.com) |
| **User-Agent**      | 클라이언트 브라우저 및 OS 정보            |
| **Accept**          | 허용 가능한 MIME 타입 (예: text/html) |
| **Accept-Language** | 허용 언어 설정 (예: ko-KR)           |
| **Accept-Encoding** | 압축 방식 (예: gzip, deflate)      |
| **Referer**         | 요청이 어디에서 왔는지                  |
| **Cookie**          | 클라이언트가 저장한 쿠키 정보 전달           |

### **4. HTTP 응답(Response)의 구조**

서버는 요청에 대한 응답으로 아래와 같은 헤더를 보냅니다:

| **필드**               | **설명**                     |
| -------------------- | -------------------------- |
| **HTTP Version**     | 서버 응답 버전                   |
| **Status Code**      | 응답 결과 상태 (예: 200 OK)       |
| **Content-Type**     | 반환된 데이터의 형식 (예: text/html) |
| **Content-Encoding** | 데이터 인코딩 방식 (예: gzip)       |
| **Set-Cookie**       | 서버가 클라이언트에 저장시키는 쿠키        |
| **Date**             | 응답이 생성된 날짜                 |
| **Content-Length**   | 응답 본문의 바이트 크기              |

![](https://velog.velcdn.com/images/bini/post/f607f30f-2141-40dd-aa70-120a84563241/image.png)

### **5. HTTP 상태 코드 (Status Code)**

| **코드**                        | **의미**             |
| ----------------------------- | ------------------ |
| **200 OK**                    | 요청 정상 처리           |
| **201 Created**               | 요청 성공 + 새로운 자원 생성  |
| **301 Moved Permanently**     | 영구적으로 URL이 변경됨     |
| **302 Found**                 | 일시적인 리다이렉션         |
| **400 Bad Request**           | 잘못된 요청 (문법 오류 등)   |
| **403 Forbidden**             | 권한 없음, 접근 금지       |
| **404 Not Found**             | 요청한 리소스가 없음        |
| **500 Internal Server Error** | 서버 내부 오류로 요청 처리 실패 |

---
## 웹 서비스 기본 구조

웹에서 사용하는 프로토콜인 **HTTP는 텍스트 기반, 즉 문자열 형태의 프로토콜**입니다.
우리가 브라우저에서 보는 모든 HTTP 요청과 응답은 사람이 읽을 수 있는 **문자 문자열**로 구성되어 있습니다.

그런데 이 문자열 기반의 HTTP가 전송되기 위해서는
그 아래에 있는 **TCP/IP라는 바이너리 기반의 전송 인프라**가 반드시 필요합니다.

1. **HTTP 메시지는 문자열**입니다. 브라우저가 만든 요청은 텍스트 형태의 요청입니다. 
2. 이 문자열은 **TCP 소켓을 통해 전송**됩니다.
    TCP는 전송 제어 프로토콜로, 데이터를 **스트림(stream)** 형태로 보냅니다.
    스트림이란 “시작은 있지만 끝이 명확하지 않은 연속적인 데이터 흐름”입니다.
3. TCP는 이 스트림을 일정한 크기로 잘라 **세그먼트(segment)** 라는 단위로 쪼개고,이를 IP 계층에서 **패킷(packet)** 으로 감싸 전송합니다.
4. 수신 측에서는 이 쪼개진 세그먼트를 다시 모아, 원래의 HTTP 문자열 메시지로 복원합니다.

###  1. 초창기 웹의 동작 구조

 html 문서를 주고받기 위한 방법으로 HTTP라는 프로토콜을 설계했습니다. 사용자가 브라우저에 URL을 입력하면
1. 입력한 도메인을 DNS를 통해 IP로 변환
2. TCP/IP 연결 수립
3. HTTP GET 요청 전송
4. 서버가 HTML 문서를 응답
5. 브라우저가 해당 HTML을 렌더링
**브라우저는 문서 뷰어였다는 것**입니다. HTML 문서를 받아와 화면에 보여주는 것이 전부였고, 사용자는 링크를 클릭하면 새로운 문서를 다시 요청하는 구조였습니다.

### 2. 웹의 구성 원칙과 발전

개발자들 사이에서 오래된 설계 원칙이 하나 있습니다. 소프트웨어를 구성할 때는 유지보수가 쉽게 설계해야합니다.
- UI (화면을 그리는 영역)
- Data (데이터를 저장·관리하는 영역)
- Control (로직과 흐름을 제어하는 영역)

이 원칙은 나중에 MVC로 구체화되었고, 웹 아키텍처에도 영향을 줍니다. 처음에는 HTML만 주고받다가, ‘문서를 예쁘게 꾸미고 싶다’는 요구가 생기면서 CSS가 등장했고, 더 나아가 사용자 인터랙션을 가능하게 하기 위해 JavaScript가 도입되었습니다.

JS는 처음에는 MochaScript로 시작했지만, 이후 LiveScript를 거쳐 JavaScript라는 이름으로 자리 잡았고, 현재는 웹 페이지에 동적 기능을 제공하는 핵심 기술로 자리잡았습니다.

### 3. 클라이언트 요청 방식의 변화

초기에는 클라이언트가 문서를 요청하고 서버가 응답하는 **단방향 구조(GET 요청)** 만 있었습니다. 하지만 로그인, 회원가입처럼 사용자의 입력을 처리해야 하는 시나리오가 등장하면서, **양방향 상호작용(POST 요청)** 이 필요해졌습니다.

예를 들어, 로그인 시 사용자는 ID와 PW를 입력하고 로그인 버튼을 누릅니다. 이 데이터는 POST 방식으로 서버에 전달되며, 서버는 이 값을 기반으로 검증을 수행해야 합니다.

### 4. Stateless한 HTTP

HTTP는 기본적으로 Stateless입니다. 요청 간의 연결 정보나 사용자의 상태를 기억하지 않습니다. 하지만 로그인 같은 기능을 위해서는 사용자의 상태를 기억할 필요가 있습니다.

그래서 등장한 개념이 바로 **쿠키(Cookie)** 입니다. 클라이언트는 로그인 등의 정보를 쿠키에 저장하고, 서버는 이 쿠키를 통해 사용자의 상태를 확인합니다. 서버는 다수의 사용자의 정보를 관리해야 하므로 보통 별도의 **DB 서버**를 두고 이 정보를 저장합니다.


### 5. 서버 구조의 분리

처음에는 하나의 서버가 모든 역할을 담당했지만, 웹 서비스가 복잡해지고 규모가 커지면서 각 역할이 명확히 분리되었습니다.
- **Web Server**는 정적인 리소스(HTML, CSS, JS, 이미지)를 전송합니다.
- **WAS (Web Application Server)**는 클라이언트의 요청을 처리하고, 로직을 실행하며 DB와의 연결을 담당합니다.
- **DB Server**는 사용자 정보나 서비스 데이터를 저장·조회합니다.

로그인 예시로 다시 돌아보면, 클라이언트가 입력한 ID와 PW는 웹 서버를 거쳐 WAS로 전달되고, WAS는 이를 DB에 질의합니다. 결과가 일치하면 HTML 응답을 생성하여 다시 사용자에게 전달합니다.

### 6. MVC 구조로의 전환

이렇게 서버의 역할이 분리되면서 웹 애플리케이션은 자연스럽게 **MVC 구조**로 발전합니다.
- **Model**: DB 및 데이터 처리 (ex. 사용자 정보, 게시물)
- **View**: 사용자에게 보여지는 화면 (HTML, 템플릿 엔진)
- **Controller**: 요청을 받고 흐름을 제어 (Spring Controller 등)

이 구조는 유지보수성과 확장성을 높여주며, 웹 개발의 기본 설계로 자리 잡았습니다.

### 7. 응답 시간과 APM

웹 서비스가 아무리 복잡하고 멋져도, **느리면 무용지물**입니다.
요청-응답이 지연된다면 사용자 경험은 크게 저하됩니다.

  그래서 **응답시간** 을 모니터링하는 도구가 필요하며, 이를 **APM(Application Performance Monitoring)** 이라고 합니다.

대표적인 도구로는 **Scouter**가 있으며, APM은 다음을 주로 추적합니다.
- WAS의 처리 속도
- JVM 상태 (스레드, GC, 메모리 사용 등)
- 오류 발생 여부
- DB 질의 시간

이 정보는 장애 발생 시 병목 구간을 정확히 추적하는 데 도움이 됩니다.

### 8. WAS와 Spring의 역할

Java 기반 웹 시스템에서는 **JVM 위에서 어플리케이션이 실행**됩니다.
WAS는 이러한 JVM 기반에서 돌아가며, 대표적으로 **Tomcat**이 있습니다.
JSP 파일은 실행 시 **Servlet**으로 변환되어 동작합니다.  

Spring은 이러한 Servlet 구조에서 더욱 효율적인 개발을 가능하게 해주는 **프레임워크**입니다.

결과적으로, 사용자의 요청에 따라 **코드 뭉치**가 생성되고 실행되며, 필요시 DB와 통신하고, 응답을 클라이언트에 전달하게 됩니다.

### 9. HTML이 아니라 JSON을 보내는 구조
  
과거에는 서버가 클라이언트에 **HTML 문서 전체를 만들어 응답**했습니다.
브라우저는 단지 이를 렌더링하는 역할만 했죠. 이 방식은 단방향이며, 화면 구성은 서버에서 결정됩니다.

하지만 시대가 바뀌며, 사용자 환경이 PC뿐만 아니라 모바일, 태블릿 등으로 다양해졌습니다.
이 모든 환경을 **HTML로 다 커버하려니 번거롭고 비효율적**이었죠.

그래서 **“데이터와 UI를 분리하자”** 는 패러다임이 등장했습니다.  

서버는 이제 **HTML 대신 JSON/XML과 같은 순수 데이터만 응답**합니다.
이 데이터는 **React, Vue 같은 JavaScript 프레임워크**가 클라이언트에서 받아서
사용자 환경에 맞는 UI를 즉시 구성합니다.


## HTTP와 TCP

- **HTTP는 데이터를 주고받기 위한 고수준 통신 프로토콜**
- **TCP는 데이터를 안정적으로 전송하기 위한 기반 프로토콜**    
- HTTP는 자체적으로 전송 기능이 없기 때문에, 반드시 TCP를 통해 동작

>  **HTTP는 TCP 위에서 작동하는 상위 계층 프로토콜**

### 1. TCP는 stateful, HTTP는  stateless

#### **TCP (Stateful)**

- 3-way-handshake로 **명시적 연결 수립**
- 데이터 송수신 중에도 상태(Sequence, ACK, Window 등) 지속적으로 추적
- 연결 종료 시 4-way-handshake로 마무리
- 상태 정보를 기억하며 통신하기 때문에 stateful
#### **HTTP (Stateless)**

- 요청 → 응답 → 종료 (HTTP/1.x 기준)
- **서버는 요청이 끝나면 클라이언트의 상태를 기억하지 않음**
- 따라서 클라이언트는 매 요청마다 쿠키나 토큰을 통해 자신의 상태를 명시적으로 전달해야 함
- 각 요청은 **독립적이며 무관한 작업**으로 처리됨

>  **TCP는 연결을 유지하고 추적하지만**, **HTTP는 그 연결 위에서 상태를 기억하지 않고 요청만 처리**함


### 2. HTTP는 연결을 유지하지 않는 걸까

- **HTTP/1.0**: 요청/응답 후 매번 TCP 연결 종료
- **HTTP/1.1부터**: Connection: keep-alive를 통해 **TCP 연결을 재사용** 가능 (같은 클라이언트)
- 연결이 살아있다 해도 **HTTP는 이전 요청의 상태를 기억하지 않음**
- 상태 유지를 위해 별도로 **세션, 쿠키, 토큰 등을 사용**함


>  **TCP 연결은 유지될 수 있어도, HTTP 프로토콜 자체는 무상태(stateless)** 입니다.

### 3.  Spring 웹 애플리케이션에서 어떻게 동작하나?
#### **1요청 = 1TCP소켓 = 1스레드 구조 (Spring MVC + Tomcat 기준)**

- 클라이언트가 브라우저에서 HTTP 요청을 보냄
- 이 요청은 TCP 연결을 통해 들어오고, 서버는 **소켓을 생성** 
- **Tomcat은 스레드풀에서 스레드 하나를 할당**해 해당 요청을 처리
- 요청 → DispatcherServlet → Controller → Service → DB 순으로 처리됨
- 응답을 반환하면 스레드는 풀로 돌아감

### 4. 많은 사용자가 접속하면 무슨 문제가 생길까?

#### **병목은 “TCP 소켓”보다 “스레드 수”에서 먼저 발생**
- OS는 수만 개의 TCP 소켓을 감당할 수 있음
- 그러나 **JVM에서 동시에 처리 가능한 스레드는 수천 개 정도**
- 스레드는 **스택 메모리, 컨텍스트 스위칭 비용 등 자원을 많이 소모**
