
## TCP와 UDP 개요
### **1. TCP와 UDP의 개요**

TCP와 UDP는 인터넷에서 가장 핵심적인 전송 계층(L4) 프로토콜입니다. 이 둘은 겉보기엔 비슷해 보이지만, 성격은 완전히 다릅니다. 

### **2. TCP에는 ‘연결’ 개념이 있다**

TCP의 핵심은 ’연결지향성’입니다. 이 연결은 단순히 물리적인 의미가 아니라, **논리적인 연결**, 즉 가상의 회선을 뜻합니다. 이때 ‘연결’이라는 표현은 영어로는 **Connection** 또는 **Session**이라는 두 용어가 혼용되어 사용됩니다.

연결이란, 데이터를 주고받기 위한 가상의 통로를 미리 만들어놓는 것을 말합니다. 그리고 이 연결을 가능하게 해주는 중요한 개념이 바로 **순서번호** 입니다.

### **3. 순서번호와 상태 전이(State Transition)**

TCP는 데이터를 **Segment**라는 단위로 쪼개어 보냅니다. 이때 각 Segment에는 번호가 붙습니다.
예를 들어, 첫 번째 조각의 시퀀스 번호가 1이고 그 크기가 400바이트라면, 다음 조각의 번호는 401입니다. 이런 식으로 순서를 정해 두면, 수신 측은 퍼즐처럼 조각을 맞춰 원래 데이터를 복원할 수 있습니다.

그리고 이 연결은 상태 개념과 함께 작동합니다. 마치 전화기를 예로 들 수 있죠.
- **전화번호를 누르기 전** → 연결 시도 전
- **통화 연결음이 울릴 때** → 연결 중
- **통화 중** → 연결 상태
- **전화 끊음** → 연결 종료

TCP도 이와 유사한 일련의 **상태 전이(State Transition)** 과정을 거쳐 연결을 관리합니다.

### **4. TCP vs UDP**

- **TCP**는 데이터를 보내기 전에 수신측 상황을 확인합니다. 만약 수신측에 여유공간이 없다면 Zero Window라는 신호를 보고, **기다렸다가** 나중에 데이터를 전송합니다.

- **UDP**는 상대방 사정은 고려하지 않습니다. 그냥 **무조건 보냅니다**. 그래서 빠르긴 하지만, 신뢰성이 떨어질 수 있습니다. 책임지지 않고 그냥 떠나는 타입입니다.

### **5. TCP 연결의 실제 구성**

TCP 통신은 보통 **클라이언트-서버 모델**로 작동합니다.
- 클라이언트는 **적극적으로 연결을 시도**합니다.
- 서버는 **수동적으로 기다리며 연결을 받습니다.** 

클라이언트가 소켓을 열면 운영체제(OS)는 여유 있는 포트 번호를 하나 배정합니다.
 **1.**  **서버 입장 (포트 고정)**
- 서버는 **항상 고정된 포트를 사용**합니다.
- 클라이언트가 서버에 접근할 때 **포트를 알아야 접속 가능**하기 때문입니다.
**2.**  **클라이언트 입장 (포트는 보통 자동 할당)**
- 클라이언트는 **서버의 IP:포트**에 접근하면서, 자신의 포트는 보통 명시하지 않습니다.
- 이때 OS가 클라이언트의 소켓에 임시 포트를 할당합니다.
- 이 포트 번호는 일반적으로 **49152~65535 범위**에서 랜덤하게 배정됩니다.

서버는 소켓을 생성하고, listen 상태로 대기합니다. 클라이언트가 연결 요청을 보내면 OS는 서버가 해당 포트를 사용할 권한이 있는지 확인하고, 가능하면 연결을 수립합니다.

**만약 서버에 해당 포트를 듣는 프로세스가 없다면?** TCP 스택이 “연결 불가” 응답을 보내게 됩니다.

---
## **TCP 연결과정 3-Way Handshaking**

###  1. 연결과 3-Way Handshaking의 관계

TCP는 흔히 **연결지향형 프로토콜**이라고 불리며, 이 “연결“이라는 개념을 중심으로 동작합니다.
**3-Way Handshaking이라는 절차** 를 통해 **양측이 통신할 준비가 되었음을 확인**하는 과정을 거치며,
이 과정을 마친 뒤에야 데이터 송수신이 가능한 상태가 됩니다.

### **2. 통신 흐름의 예시**
통신 단위는 **Segment**이며, 일반적으로는 payload와 TCP Header로 구성되어 있지만,
3-way-handshaking 과정에서는 **payload 없이 TCP Header만 담긴 관리용 Segment**가 오고 갑니다.

### **3. 세 단계의 연결 절차**
#### **1단계: SYN (클라이언트 → 서버)**

먼저 클라이언트는 서버와 연결을 시작하기 위해 **랜덤한 Sequence Number**를 생성합니다.
예를 들어, 1000번이 생성되었다면,
클라이언트는 서버에 **SYN(1000)** 메시지를 보냅니다.
이 시점에서 클라이언트의 상태는 **SYN_SENT**입니다.
#### **2단계: SYN + ACK (서버 → 클라이언트)**

서버가 연결 가능한 상태라면 자신도 랜덤한 Sequence Number를 생성합니다.
이를테면 4000이라고 할 때, 서버는 클라이언트에게
**SYN(4000) + ACK(1001)** 를 전송합니다.

> 여기서 ACK(1001)은 “네가 보낸 1000번은 잘 받았고, 이제 1001부터 보내줘”라는 의미입니다.

이 메시지를 보내기 전, 서버의 소켓은 반드시 **LISTEN 상태**여야 하며,
이 패킷을 수신하면 **SYN_RECEIVED 상태**로 전이됩니다.

#### **3단계: ACK (클라이언트 → 서버)**
클라이언트는 서버의 응답을 받고, 이를 확인했다는 의미로
**ACK(4001)** 메시지를 보냅니다.
이 순간 클라이언트는 **“연결이 완료되었다”고 판단**합니다.

하지만 실제로는 약간의 시간차가 존재합니다.
클라이언트가 보낸 ACK가 서버에 도달하려면 약 **25ms**,
즉 단방향 RTT가 필요하죠.
서버는 이 ACK를 **직접 수신한 후에야**
비로소 연결이 성립되었다고 판단하게 됩니다.

![](https://velog.velcdn.com/images/bini/post/1a8d9e8c-0faa-475d-b657-7163d25c71bb/image.png)

### **4. 단순한 인사 이상의 의미 – 정책 교환**
3-way-handshaking 과정에서는 단순한 연결 요청 외에 다음과 같은 **정책 정보들이 교환**됩니다:
- **MSS(Maximum Segment Size) 교환**
    - 양측은 자신의 MSS를 전달하고, **더 작은 값**에 맞춰 데이터 세그먼트를 분할
        
    - 한쪽의 MSS가 작으면 전체 통신 효율 저하 가능
- **작은 MSS의 영향**
    - 세그먼트 수 증가 → **헤더 오버헤드 증가**
        
    - **ACK 빈도 증가** → CPU 및 네트워크 부하 증가
        
    - 결과적으로 **통신 속도 저하** 발생 가능
- **그 외 교환 정보**
    - **Sequence Number**: 데이터 순서 추적
        
    - **Window Size**: 흐름 제어를 위한 수신 버퍼 크기
        
    - **TCP 옵션들**: 윈도우 스케일, SACK 등 통신 최적화 요소

---
## **TCP 연결 종료  4-Way Handshaking**

### **1. 끊는 절차**

TCP는 연결을 설정할 때 3-way-handshaking이라는 절차를 따르듯,
연결을 종료할 때도 일정한 절차를 거칩니다.
이를 **4-way-handshaking**이라고 합니다.

### **2. 기본 전제: 클라이언트가 주도한다**

TCP 통신에서 일반적으로 **연결을 시작한 쪽이 연결 종료도 주도**합니다.
즉, 클라이언트가 연결했다면 종료도 클라이언트가 먼저 요청하는 것이 일반적입니다.
서버가 먼저 종료 요청을 보내는 경우는 예외적인 상황입니다.

### **3. 연결 종료의 상태 변화**

#### **클라이언트(연결 종료 요청자)**
1. ESTABLISHED 상태에서
    
2. FIN + ACK 전송 → FIN_WAIT_1 상태로 전이
    
3. 서버로부터 ACK 수신 → FIN_WAIT_2 상태
    
4. 서버로부터 FIN 수신 → TIME_WAIT 상태
    
5. 마지막으로 ACK 전송 → CLOSED 상태

TIME_WAIT 상태는 “연결을 끊자고 한 쪽이 반드시 거치는 상태”입니다.
즉, 클라이언트 측에서 TIME_WAIT이 나타나면 정상 종료를 의미하고,
서버 측에서 TIME_WAIT이 나타나면 예외적인 종료 상황으로 볼 수 있습니다.

#### **서버(연결 종료 응답자)**
1. ESTABLISHED 상태에서 클라이언트의 FIN 수신 → CLOSE_WAIT 상태
    
2. FIN + ACK 전송 → LAST_ACK 상태
    
3. 클라이언트의 ACK 수신 → CLOSED 상태

### **4. TIME_WAIT의 의미**

TIME_WAIT 상태는 단순한 대기가 아니라 다음과 같은 이유로 반드시 필요합니다.
- 지연된 패킷이 다시 도착하는 상황 방지
    
- 마지막 ACK가 손실됐을 때 재전송 대응
    
- 소켓 자원을 안전하게 회수하기 위한 최소 대기 시간 확보

### **5. 소켓 회수와 실무적 고려**

TCP 소켓은 운영체제의 자원이며 개수에 제한이 있습니다.
따라서 연결을 종료하고 CLOSED 상태가 되면 OS가 소켓을 회수하고,
해당 자원을 재사용할 수 있게 됩니다.

이러한 이유로, TCP 기반 애플리케이션에서는
**연결 종료를 클라이언트가 유도하도록 Application Protocol이 설계**되는 것이 일반적입니다.


![](https://velog.velcdn.com/images/bini/post/a988651e-e07d-46fd-8d9c-c2b187fe92f9/image.png)

---
## **TCP, UDP 헤더 형식과 게임 서버 특성**

### **1. TCP 헤더 형식**

TCP는 연결지향적이고 신뢰성을 보장하는 프로토콜로, 복잡한 헤더 구조를 갖습니다.
TCP 헤더는 **32비트 단위로 필드가 구성**되어 있습니다.

![](https://velog.velcdn.com/images/bini/post/b7e1b66b-94b6-49a0-8ce6-368fdf91efa0/image.png)
#### **주요 필드 설명**
- **Source Port / Destination Port (각 16bit)**    
    - 송신자와 수신자의 포트 번호
        
    - 범위는 0~65535, 다만 0번과 65535번은 사용할 수 없어 실제 사용 가능한 개수는 2¹⁶-2개
        
    - 이 중 **well-known port**(예: HTTP 80, FTP 21 등)는 고정된 용도로 사용되며 일반 애플리케이션에서 임의로 사용하지 않음    
- **Sequence Number**
    - 데이터의 순서를 나타내는 일련번호
        
    - 전송된 데이터의 byte 수만큼 증가함 (예: 100바이트 전송 시 100 증가)
- **ACK Number**
    - 상대방의 Sequence Number에 +1 한 값으로, 받은 데이터를 확인했다는 응답
- **Data Offset**
    - TCP 헤더의 끝, 즉 payload의 시작 위치를 알려주는 값
        
    - IP 헤더의 IHL과 유사한 기능 수행
- **Flags**
    - TCP 상태를 제어하는 중요한 비트들
        - **SYN, FIN, ACK**: 연결 설정 및 해제
            
        - **RST**: 비정상 연결 해제
            
        - **PSH**: 버퍼링 없이 즉시 전송
            
        - **URG, ECE, CWR, NS**: 혼잡 제어 및 우선 전송 제어
- **Window Size**
    - 수신 버퍼의 여유 공간을 나타냄 (흐름 제어에 사용)
- **Checksum**
    - 데이터 손상 여부를 검증하기 위한 값
### **2. UDP 헤더 형식**

UDP는 **비연결형** 프로토콜로, TCP에 비해 헤더가 단순합니다.

![](https://velog.velcdn.com/images/bini/post/274bc9f3-1d28-4409-a4d5-dff6a1168830/image.png)

총 4개의 필드만으로 구성되어 있습니다:
- **Source Port / Destination Port (각 16bit)**
    
- **Length**: 전체 UDP 메시지의 길이
    
- **Checksum**: 데이터 무결성 확인
UDP는 **혼잡 제어나 흐름 제어가 없고**, 수신 확인도 하지 않습니다.
데이터를 보낸 뒤 **책임지지 않는 구조**입니다.

### **3. 게임 서버와 UDP 사용**

그렇다면 왜 단점이 많은 UDP가 게임 서버에서 선호될까요?
- **TCP는 전송 보장과 순서 보장 때문에 느린 클라이언트가 전체 서버 동기화 속도를 늦출 수 있음**
    - → 실시간 반응성이 중요한 게임에서는 **전체 속도가 느려지는 하향 평준화** 문제가 발생함
- **UDP는 수신 확인 없이 빠르게 전송만 함**
    - → 빠르고 실시간성이 중요할 때 유리
- **서버에서 자체적으로 신뢰성과 동기화 로직을 구현**
    - TCP의 기능 중 필요한 부분만 애플리케이션 수준에서 처리

### **4. UDP의 활용 사례**
- **IPTV 등 멀티미디어 스트리밍**
    - 느린 네트워크 사용자 기준으로 맞출 경우 전체 품질이 낮아지기 때문에
        → **개별 클라이언트 상황을 고려하지 않고 송출 속도를 유지하는 방식에 적합**
- **게임 서버**
    - 예: LOL 같은 실시간 동기화가 중요한 게임에서 UDP 사용
- **HTTP/3**
    - 최신 웹 통신 프로토콜인 HTTP/3는 **UDP 기반의 QUIC 프로토콜** 위에서 동작함

---
## **TCP ‘연결’이라는 착각**

**“파일 다운로드 중 LAN 케이블을 잠깐 뽑았다가 다시 연결하면 어떻게 될까?”**
TCP 연결은 유지될까? 끊어질까?
  
LAN 케이블을 **잠깐 뽑는다고 해서 TCP 연결이 즉시 끊어지지는 않습니다.**
정확히는, 일정 시간 동안 **TCP는 연결이 유지되고 있다고 ‘착각’** 합니다.
### **1. 왜 끊어진 줄 모를까?**
- TCP에서 말하는 ‘연결’은 **L4 계층의 논리적인 연결**입니다.
- 하지만 LAN 케이블을 뽑는 건 **물리 계층(L1)** 에서 발생하는 일입니다.
- TCP는 상대에게 데이터를 보낸 뒤 **ACK(응답)** 이 오는지를 통해 연결 상태를 확인합니다.
- 응답이 오지 않으면 TCP는 데이터를 **재전송**합니다. 이걸 반복하다가 일정 기준을 넘으면 그제서야 **끊어진 것으로 판단**합니다.

### **2. 재전송 타이머와 연결 유효 시간**
- 기본적인 **재전송 타이머(RTO)** 의 시작값은 약 3초 정도로 추정되지만,
    **범용 OS에서는 1초 미만으로 짧게 시작**하는 경우가 많습니다.
- 이후 RTO는 지수적으로 증가합니다:
    1초 → 2초 → 4초 → 8초 → 16초 …
- 일반적으로 **5회 재전송 실패 시** 연결을 끊습니다.
- 따라서 실제로는 **수 초에서 수십 초까지** 연결이 살아있는 것처럼 보일 수 있습니다.
### **3. TCP 연결은 착각이다**
TCP는 애초에 연결을 “유지”하는 기능이 아니라,
**정기적인 데이터 흐름과 응답(ACK)을 통해 연결 유무를 판단**합니다.

즉, **데이터를 보내지 않으면 연결이 살아있는지도 알 수 없습니다.**

그래서 상위 애플리케이션에서는 **heartbeat(하트비트)** 라는 신호를 주기적으로 보내

연결 상태를 확인합니다.

전화 통화 중 “야 듣고 있냐?“라고 묻는 것과 비슷한 원리입니다.

### **4. 충격(Shock)의 개념**
- **LAN 케이블을 잠깐 뽑았다가 다시 꽂는 일시적인 네트워크 단절**을 TCP 관점에서는 **충격**이라고 부릅니다.
    
- 충격이 발생해도 재전송 및 응답을 통해 **연결을 복구할 수 있는 시간 여유**가 있습니다.
예를 들어:
- LAN 케이블을 1초 정도 분리했다가 다시 연결하면
    다운로드는 멈췄다가 다시 이어지게 됩니다.
    
    TCP가 연결을 완전히 끊은 건 아니기 때문입니다.

### **5. 무선 환경에서의 충격 완화**
- 유선에서는 충격이 드물지만, **무선 환경에서는 자주 발생**합니다.
	- 예: 지하철에서 유튜브 시청 중, 기지국 전환 시 순간적인 데이터 단절
- 그래도 동영상이 끊기지 않는 이유는 **버퍼(buffer)** 덕분입니다.    
    - 일정 시간 데이터를 미리 받아두고,
        네트워크가 불안정할 때 재생을 지속할 수 있도록 설계된 구조입니다.
