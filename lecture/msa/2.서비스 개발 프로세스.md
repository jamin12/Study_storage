## 1. 왜 ‘스프린트 안에서’ 마이크로서비스를 도출해야 할까?

애자일 스크럼은 "계획 -> 실행 ->  피드백" 사이클을 타임박스로 구조화한 _프로세스 프레임워크_입니다. 그러나 스크럼은 **무엇을** 설계·구현·배포할지는 알려주지 않습니다. 

마이크로서비스 아키텍처(MSA) 환경에서는 스프린트 초반에 _서비스 경계_를 정의하는 ‘마이크로서비스 도출’ 과정이 선행돼야 합니다. **서비스를 잘못 쪼개면** 개발 후반부에 빚처럼 복잡성이 누적되어 "Distributed Big Ball of Mud" 상태에 빠지기 쉽습니다.

## 2. 스프린트 내 개발 흐름 한눈에 보기

1. **Outer Architecture 정의** ― 클라우드 인프라·운영 표준 설정
    
2. **마이크로서비스 도출** ― 비즈니스·조직 맥락을 기반으로 서비스 경계 설계
    
3. **Inner Architecture 설계·구현** ― 각 서비스의 코드·데이터·API 구조 구체화
    
4. **CI & CD** ― 자동 빌드·테스트·배포 파이프라인 운용
    

> 네 단계는 하나의 스프린트 안에서 _얇게_ 반복 진화(Slice‑by‑Sprint)하는 것이 핵심입니다.

---

## 3. Outer Architecture ― 클라우드 인프라 청사진

### 3‑1. 인프라 채택 옵션

- **IaaS** (EC2, GCE): VM 수준에서 풀 컨트롤 
    
- **CaaS** (EKS, AKS, GKE): Kubernetes 기반 클러스터 
    
- **PaaS** (ECS Fargate, Cloud Run): 컨테이너 런타임 추상화 
    
- **Serverless** (Lambda, Cloud Functions): 이벤트 주도 단위 실행 
    

### 3‑2. 공통 운영 문제 & 해결 전략

| 문제        | 주요 질문             | 대표 해법                               |
| --------- | ----------------- | ----------------------------------- |
| 라우팅·로드밸런싱 | 트래픽을 어디로 보낼까?     | ALB + Ingress, Service Mesh         |
| 인증·인가     | Zero‑Trust 를 어떻게? | Cognito/OAuth2 Proxy, Istio AuthN/Z |
| 중앙 로깅     | 분산 로그의 단일 창구는?    | ELK, CloudWatch Logs                |
| 분산 추적     | 서비스 체인을 어떻게 보나?   | OpenTelemetry + Jaeger              |

### 3‑3. CI/CD 파이프라인 골격

1. **Pull Request 병합** → 자동 빌드 & 단위 테스트  
2.  **아티팩트 푸시** (ECR, Artifact Registry)  
3.  **배포** : Dev는 Auto‑Deploy, Prod는 Argo CD Progressive Delivery  
4.  **관찰 가능성** : 메트릭·로그·트레이스 통합 대시보드

> **Role Update** : 예전에는 TA(기술 아키텍트)가 담당했지만, 현재는 **CA(클라우드 아키텍트)** 영역으로 이동했습니다.

---

## 4. Inner Architecture ― 마이크로서비스 내부 설계

### 4‑1. 프론트엔드 서비스

- **UI 흐름 맵** → 페이지·상태·라우팅 정의
    
- **레이아웃 시스템** → Atomic Design, Tailwind CSS 
    
- **E2E 테스트** → Cypress 또는 Playwright 
    

### 4‑2. 백엔드 서비스

| 영역      | 핵심 질문         | 실무 포인트                      |
| ------- | ------------- | --------------------------- |
| 비즈니스 로직 | 도메인을 어떻게 코드화? | DDD 전술 패턴 (엔티티, 밸류, 애그리게잇)  |
| 데이터 모델  | 저장소·스키마는?     | RDB vs NoSQL, 이벤트 소싱        |
| API 설계  | 서비스의 외부 언어는?  | RESTful + 버저닝, gRPC/GraphQL |

### 4‑3. 서비스 연계

- **동기** : REST/gRPC  - **비동기** : Kafka, SNS/SQS  - **레거시 통합** : Database Link, Change Data Capture 

---

## 5. 마이크로서비스 도출 가이드

### 5‑1. 왜 중요한가?

잘못 쪼개면 _모노리스_와 다를 바 없는 복잡성이 분산 환경에 확산됩니다. 보수·배포 속도는 떨어지고 팀 경계도 흐려집니다.

### 5‑2. 핵심 고려사항

- **비즈니스 도메인** 응집도 
    
- **조직 구조** (팀 = 서비스 원칙) 
    
- **팀 역량** 및 인력 구성 
    
- **변경·배포 빈도** 
    
- **사용량·트래픽 패턴** 
    
- **DB 오너십 및 독립성**
    

### 5‑3. 대표적 도출 방법

1. **도메인 주도 설계(DDD)** : 바운디드 컨텍스트 기반  
2. **비즈니스 역량(Capability) 맵**  
3. **기능·프로세스 분해도**

### 5‑4. 잘못된 도출의 징후

- 서비스 개수가 폭발적으로 늘어나는 경우  - DB 스키마 공유 (테이블 폴더 공유 등)  - 한 배포가 다른 서비스 빌드·배포를 연쇄 트리거 

> **목표** : "_적절한 크기_의 서비스 + _느슨한 호출 관계_"를 찾는 것.

### **마이크로서비스 식별: “작게 쪼개라” 보다 “알맞게 쪼개라”**

1. **비즈니스 캡터빌리티(역량) 기준**
    
    - 주문·배송·결제처럼 ‘한 팀이 한 역량’을 담당하도록 기능 분해(Function Decomposition)
        
    
2. **도메인 주도 설계(DDD)의 Bounded Context**
    
    - 프로세스·용어가 충돌 없이 독립 실행 가능한 경계로 MSA를 구획
        
    
3. **데이터 및 운영 독립성**
    
    - 데이터베이스 소유권이 겹치면 마이크로서비스 간 배포∙스케일링 이점이 사라진다
        
    
4. **복잡성 균형**
    
    - **모노리스**: 로컬 복잡성↑, 글로벌 복잡성↓
        
    - **잘못 쪼갠 MSA**: 로컬 복잡성↓, 글로벌 복잡성↑
        
    - **목표 지점**은 _두 복잡성을 모두 ‘적당히’ 낮춘_ 중간 영역

안녕하세요! 마이크로서비스 아키텍처에서 **애자일 스크럼 프로세스**는 개발의 큰 틀을 제공하지만, 각 서비스의 내부와 외부를 연결하는 **API 설계**는 그 효율성과 확장성을 결정짓는 핵심 요소입니다. 특히 **REST API**는 오늘날 마이크로서비스 통신의 표준처럼 자리 잡았죠. 이번 글에서는 마이크로서비스 개발에서 REST API를 어떻게 설계해야 하는지, 그 주요 개념과 모범 사례들을 자세히 살펴보겠습니다.

---

### **마이크로서비스와 REST API**

마이크로서비스 아키텍처는 독립적인 서비스들이 서로 통신하며 기능을 수행합니다. 이 서비스 간의 통신에서 핵심적인 역할을 하는 것이 바로 **API(Application Programming Interface)** 입니다. 특히 **REST API**는 백엔드와 프론트엔드가 서로 약속하고 정보를 주고받는 **'계약(Contract)'** 과 같은 역할을 합니다.

**REST API가 대중적인 권위를 얻게 된 이유**는 무엇일까요?

- **HTTP 프로토콜 및 JSON 데이터 포맷의 광범위한 사용**: 기존의 소켓 통신이나 SOAP(SWAP) 방식에 비해 **매우 쉽고 편하게 사용**할 수 있다는 점이 큰 장점입니다.
- **자원의 정보를 주고받는 구조**: HTTP 프로토콜과 JSON 포맷을 활용하여 '데이터 자원'의 정보를 주고받는 구조를 의미합니다.

이러한 특성 덕분에 프론트엔드 개발자는 백엔드가 제공하는 API 규약에 따라 독립적으로 개발할 수 있고, 백엔드 개발자도 정의된 API에 맞춰 서비스를 설계하고 개발할 수 있게 됩니다.

---

### **REST API의 핵심 구성 요소**

REST API는 자원(Resource), 행위(Action), 표현(Representation)이라는 세 가지 핵심 요소를 가집니다.

1. **자원(Resource)**:
    
    - **URI(Uniform Resource Identifier)로 표현**됩니다. 예를 들어, `/docs`나 `/docs/1`와 같이 명사를 사용합니다.
    - 일반적으로 API의 기능을 표현하기 위해 `getDocs`나 `setDocs`와 같이 **동사를 URI에 포함하는 것은 바람직하지 않습니다**. 대신, 리소스를 나타내는 **명사**를 사용하는 것이 좋습니다.
2. **행위(Action)**:
    
    - **HTTP 메소드를 통해 정의**됩니다. URI 자체에 기능을 정의하는 것이 아니라, HTTP 메소드가 자원에 대한 어떤 행위를 수행할지 명시합니다.
    - **주요 HTTP 메소드 및 그 의미**:
        - **POST**: 리소스 **생성**
        - **GET**: 리소스 **조회** (예: `/docs`는 목록 조회, `/docs/1`은 1번 개체 조회)
        - **PUT**: 리소스 **수정** (예: `/docs/1`에 PUT 요청 시 1번 개체 수정)
        - **DELETE**: 리소스 **삭제** (예: `/docs/1`에 DELETE 요청 시 1번 개체 삭제)
3. **표현(Representation)**:
    
    - HTTP 요청에 대한 응답으로 **JSON 타입의 데이터 포맷**으로 자원의 정보를 표현합니다.

이러한 규칙들을 정함으로써, 개발자는 별도의 가이드 문서 없이도 URI와 HTTP 메소드만 보고도 API가 어떻게 동작할지 쉽게 인지하고 사용할 수 있게 됩니다.

---

### **REST API 설계의 중요 개념: 멱등성과 무상태성**

성공적인 REST API 설계를 위해서는 **멱등성(Idempotency)**과 **무상태성(Statelessness)** 개념을 이해하고 적용하는 것이 좋습니다.

- **멱등성(Idempotency)**:
    
    - **개념**: 반복적으로 호출하더라도 시스템의 상태가 계속 유지되거나 변화가 없는 성질을 의미합니다.
    - **적용**:
        - **GET, PUT, DELETE** 메소드는 일반적으로 멱등성을 가지도록 설계할 수 있습니다. (예: 1번 데이터를 100번 조회해도 데이터는 변하지 않음).
        - **POST** 메소드는 리소스를 '생성'하는 행위이므로 멱등성을 따르지 않습니다. (예: 100번 POST 요청 시 100개의 리소스가 생성될 수 있음).
- **무상태성(Statelessness)**:
    
    - **개념**: API가 클라이언트의 상태 정보(예: 세션 정보)를 가지고 있지 않는 성격입니다.
    - **장점**:
        - **뛰어난 확장성(Scalability)**: 상태를 보존할 필요가 없으므로 여러 인스턴스로 쉽게 스케일 아웃할 수 있습니다. 상태 유지가 필요한 경우(stateful)에는 세션을 공유하는 문제 등을 극복해야 합니다.
    - **권장 사항**: REST API는 반드시 무상태성으로 설계되어야 하는 것은 아니지만, **무상태성으로 설계하고 멱등성을 가지게 설계하는 것이 권장**됩니다.

---

### **REST API 성숙도 모델: Richardson 모델**

REST API의 수준을 평가하는 데 널리 인용되는 것이 바로 **Richardson의 성숙도 모델**입니다. 이 모델은 REST API가 얼마나 RESTful한지 3가지 레벨로 구분합니다.

- **레벨 1: 리소스 식별 (Resources)**
    
    - **설명**: 리소스를 누구나 인지할 수 있는 **명사 기준**으로 작성하는 수준입니다. URI에 동사를 사용하지 않고 명사를 사용하여 자원을 표현하는 것이 여기에 해당합니다.
    - **예시**: `GET /docs` (문서 목록 조회)
- **레벨 2: HTTP 동사 사용 (HTTP Verbs)**
    
    - **설명**: **GET, POST, PUT, DELETE**와 같은 HTTP 동사들을 그 원칙(조회, 추가, 수정, 삭제)에 따라 올바르게 호출하여 구현하는 수준입니다. 대부분의 REST API 프로젝트는 최소한 이 수준까지는 준수합니다.
    - **예시**:
        - `POST /docs` (새 문서 생성)
        - `GET /docs/{id}` (특정 문서 조회)
- **레벨 3: HATEOAS (Hypermedia as the Engine of Application State)**
    
    - **설명**: REST API의 궁극적인 모델로, **API 호출 결과에 추가적으로 사용할 수 있는 관련 API 정보를 함께 제공**하는 방식입니다. 이는 클라이언트가 다음 동작을 위해 어떤 API를 호출해야 하는지 스스로 발견할 수 있게 돕습니다.
    - **예시 (은행 계좌 조회)**:
        - `GET /accounts/{accountNumber}`로 특정 계좌 정보를 조회합니다.
        - 응답으로 계좌 정보와 함께, 현재 상태에 따라 **수행 가능한 다른 행위들의 API 링크**가 제공됩니다.
        - 예를 들어, 잔액이 $100인 계좌를 조회했다면, **입금(deposit), 인출(withdraw), 이체(transfer)를 위한 API 링크**가 함께 제공됩니다.
        - 만약 잔액이 -$25인 계좌를 조회했다면, **입금(deposit) API 링크만 제공**하고 인출이나 이체는 불가능하므로 관련 링크를 제공하지 않을 수 있습니다. 이는 API가 마치 인공지능처럼 상황에 맞는 API를 알려주는 것과 같습니다.

---

### **REST API 설계 문서화 및 도구**

API 설계는 명확한 문서화와 효율적인 도구의 도움을 받을 수 있습니다.

- **전통적인 방법**: **엑셀**을 사용하여 URI 명, HTTP 메소드, 입출력 값, 응답 샘플 등을 정의할 수 있습니다.
- **현대적인 도구**: 최근에는 **Swagger**와 같은 도구들이 REST API 스펙을 보여주고, 간단한 테스트 기능까지 제공하여 개발 편의성을 높여줍니다.
