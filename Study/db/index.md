# index
## __<span style="color:#9999ff">인덱스 란?</span>__
- 인덱스틑 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조이다.</br> 테이블의 특정 컬럼에 인덱스를 생성하면 **해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장 된다.** 컬럼의 값과 물리적 주소를 (key,value)의 한쌍으로 저장한다.
- 인덱스는 택에서의 목차 혹은 색인이라고 생각하면 된다. 책에서 원하는 내용을 찾을 때 목차나 색인을 이용하면 훨씬 빠르게 찾을 수 있는데, 마찬가지로 테이블에서 원하는 데이터를 찾기 위해 인덱스를 이용하면 빠르게 찾을 수 있다.
- ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbPb8pb%2FbtrePWRO9HY%2FqrzMfX84KAAuFgkyZkKtKK%2Fimg.png)
## __<span style="color:#9999ff">인덱스의 장단점</span>__
### __<span style="color:#ff9933">장점 </span>__
- 인덱스의 장점으로는 테이블을 검색하는 속도와 성능이 향상된다. 또 그에 따라 시스템의 전반적인 부하를 줄일 수 있다.</br> 핵심은 인덱스에 의해 데이터들이 **정렬된 형태를 갖는다는 것이다.** 기존엔 Where문으로 특정 조건의 데이터를 찾기 위해서 테이블의 전체를 조건과 비교해야하는 풀 테이블 스캔(full table scan)작업이 필요했는데, 인덱스를 이용하면 데이터들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다.</br> order by 문이나 min max같은 경우도 이미 정렬이 되어 있기 때문에 빠르게 수해할 수 있다.
### __<span style="color:#ff9933">단점</span>__
- 인덱스가 항상 정렬된 상태로 유지되어 오는 장점도 있지만, 그에 따른 여려 단점도 존재한다.
  1. 인덱스를 관리하기 위한 추가 작업이 필요
  2. 추가 저장 공간 필요
  3. 잘못 사용하는 경우 오히려 검색 기능 저하
- 인덱스를 항상 정렬된 상태로 유지해야 하기 떄문에 인덱스가 적용된 컬럼에 삽입, 삭제, 수정 작업을 수행하면 다음과 같은 추가 잡업이 필요하다
  1. insert: 새로운 데이터에 대한 인덱스 추가
  2. delete: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
  3. update: 기존 인덱스를 사용하지 않음 처리, 갱신되 데이터에 대한 인덱스 추가
- 이처럼 인덱스의 수정도 추가적으로 필요하기 때문에 데이터의 수정이 잦은 경우 성능이 낮아진다. 또 데이터의 인덱스를 **제거하는 것이 아니라 '사용하지 않음'으로 처리하고 남겨두기 때문에** 수정작업이 많은 경우 실제 데이터에 비해 인덱스가 과도하게 커지는 문제점이 발생할 수 있다. 별도에 메모리 공간에 저장되기 떄문에 추가 저장 공간이 많이 필요하게 된다.
- 또한 인덱스의 전체 데이터의 10 ~ 15% 이상의 데이터를 처리하거나 데이터 형식에 따라 오히려 성능이 낮아질 수 있다.
## __<span style="color:#9999ff">인덱스를 사용하면 좋은 경우</span>__
- 인덱스를 효율적으로 사용하기 위해선 데이터의 range가 넓고 중보깅 적을수록, 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용하는 것이 좋다. 따라서 다음과 같은 경우들에 인덱스를 사용하면 효율적이다.</br> 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성된다. 이 기준 컬럼은 최대한 중복되지 않는 값이 좋다. 가장 최선은 PK로 인덱스를 거는 것이다.
  - 규모가 큰 테이블
  - 삽입, 수정, 삭제 작업이 자주 발생하지 않는 컬럼
  - where나 order by, join등이 자주 사용되는 컬럼
  - 데이터의 중복도가 낮은 컬럼
## __<span style="color:#9999ff">인덱스 자료구조</span>__
인덱스는 여러 자료구조를 이용해서 구현할 수 있는데, 대표적으로 해시 테이블과 B+Tree가 있다.
- __<span style="color:#ff9933">해시 테이블</span>__
  - 해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조이다.(key, value)로 쌍을 표현하며, 해시 충졸이라는 변수가 존재하지만 평균적으로 O(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조이다.
  - 해시 테이블을 이용한다면 인덱스는 (key, value) = (컬럼의 값, 데이터의 위치)로 구현하는데, 해시 테이블은 등호(=)연산에 최적화 되어있기때문에 부등호(< >) 연산을 할때 빠른 시간 내에 값을 찾을 수 없어 실제로 인덱스에서 잘 사용되지 않는다.
- __<span style="color:#ff9933">B+ Tree</span>__
  - 기존의 B-Tree는 어든 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다. 이러한 단점을 개선시킨 자료구조가 B+ tree이다.
  - B+ tree는 오직 leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장한다. 그리고 leaf node끼리는 LinkedList로 연결되어있다.</br> 또 B+ tree에서는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node에서 key를 올바르게 찾아가기 위해서 key가 중복될 수 있다.
  - ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAARBC%2FbtrdDydoUp7%2F9h4KOXBRyDNKpKDAe2ugq0%2Fimg.png)
  - leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기때문에 트리의 톺이가 더 낮아지므로 검색 속도를 높일 수 있다.
  - full scan을하는 경우 B+ tree는 leaf node에만 데이터가 저장되어 있고 leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B- tree는 모든 node를 확인해야한다.
  - 반면 B- tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있지만 b+tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 가야하는 단점이 있다.

# 참고
- https://choicode.tistory.com/27
- https://rebro.kr/167