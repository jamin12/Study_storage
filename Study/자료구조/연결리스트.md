# 연결 리스트(linked List)
## 배열과 연결리스트 장 단점
||장점|단점
|---|---|---|
배열| - 랜덤 엑세스가 빠르다</br>- 즉, 매우 빠르게 접근 가능|- 메모리 사용이 비효율적</br>- 배열 내의 데이터 이동 및 재구성이 어렵다.
연결리스트|- 동적으로 메모리 사용가능</br>- 메모리 효율적 사용</br>- 데이터 재구성용이</br>- 대용량 데이터 처리 적합|- 특정 위체 데이터 검색할때 느리다.</br>- 메모리를 추가적으로 사용해야한다.
- 배열은 접근이 빠르고 간단하다. n번째 인덱스에 접근할 경우 arr[n]을 사용하면 빠른 시간에 접근할 수 있습니다.</br> 그러나 배열을 사용하기 위해서는 처음에 배열 크기를 선언해야 하고 크기의 수정이 불가능하기 때문에 메모리 사용이 비효율적입니다.</br>또한 중간 데이터를 삭제 했을때 빈 배열을 처리하는 것이 번거롭습니다.
- 그러나 연결 리스트는 위의 단점을 해결할 수 있습니다.</br>필요할떄마낟 데이터를 생성하여 연결하면 되기때문에 메모리를 효율적으로 사용가능합니다. 그러므로 삭제 및 추가를 할때 데이터 재궁성이 용이합니다.</br>그러나 탐색이 느립니다. 첫번째 혹은 마지막 노드를 탐색할때숩게 찾을 수 있지만 중간 노드를 탐색할 경우 첫노드부터 순차적으로 탐색해야 하기 때문에 느리고 구현이 까다롭습니다.</br>또한 데이터저장할 공간 뿐만 아니라, 다음 노드의 주소를 저장하는 공간이 추가적으로 필요하다는 단점이 있습니다.
## 연결 리스트
1. __<span style="color:#ff9933">노드</span>__
   - 연결리스트는 '노드'라는 객체로 이루어져 있습니다.
   - ![](https://t1.daumcdn.net/cfile/tistory/997DB0335A02A6D62C)
   - 위 그림과 같이 Data를 저장할 공간과 다음 주소를 가리킬 공간이 필요합니다. 사용자가 입력한 정보를 DATA영역에 담고 노드가 추가될 때마다 Next address를 이용하여 다음 노드와 연결합니다.
2. __<span style="color:#ff9933">구조</span>__
   - 전체적인 연결리스트 구조는 아래와 같이 나타낼 수 있습니다.
   - ![](https://t1.daumcdn.net/cfile/tistory/99142B335A02A86E10)
   - 이와 같이 각 노드는 연속된 공간에 저장되어 있지 않고 메모리의 여러부분에 분포되어 있습니다.</br>각 노드에 다음 노드 주소를 저장함으로써 다음 노드를 탐색할 수 있습니다. 다음 주소를 가리켜야 하기 때문에 포인터를 이용해 구현할 수 있습니다.</br>노드가 가르키는 다음 주소가 NULL이면 이 노드는 마지막 노드라고 할 수 있습니다.
3. __<span style="color:#ff9933">구현</span>__
   - 초기화
     - 노드를 접근하기위해서는 맨 처음 노드의 주소를 가리킬 노드가 필요합니다. 이 노드를 head라고 표현하겠습니다.</br>또한 나중에 구현 삽입의 시간복잡도를 줄이기 위해 마지막 노드를 가르키는 노드 tail을 하나 만들겠습니다.</br>초기화 과정에서 다음 주소를 가리키는 포인터는null로 설정합니다.
   - 삽입
     - 다음과 같은 연결리스트가 있을 때 새로운 노드를 추가하는 방법에 대해 알아보겠습니다.
     - ![](https://t1.daumcdn.net/cfile/tistory/99E8C0335A02B3200B)
     - 맨 앞에 삽입하는 방법
       - 새로 추가되는 노드의 다음주소 --> 현재 head가 가르키는 주소</br>head가 가리키는 주소 --> 추가된 노드
       - 이렇게 추가할 수 있습니다.
       - ![](https://t1.daumcdn.net/cfile/tistory/997115335A02B5843C) 
     - 맨 마지막에 삽입하는 방법
       - 맨 앞에 삽입하는 경우와 거의 같습니다. head 대신 tail를 사용하면 됩니다.</br>여기서 tail 노드의 필요성을 알 수 있습니다. 만약 tail노드가 없다면 매번 삽입할 때 마다 처음부터 끝까지 탐색해야 하는 번거로움이 발생합ㄴ디ㅏ. 그래서 매번 O(n)의 시간복잡도가 발생합니다. 만약 tail노드가 있다면 O(1)의 시간복잡도로 처리할 수 있습니다.
       - 새로 추가되는 노드의 다음 주소 --> null</br>tail이 가리키는 노드의 다음주소 --> 새로 추가되는 노드</br>tail이 가리키는 주소 --> 새로 추가된 노드
       - ![](https://t1.daumcdn.net/cfile/tistory/996ABF335A02B6F023)
     - 원하는 위치에 삽입하는 방법
       - 만약 2번째,3번째자리에 추가하고 싶다. or 정렬을 하면서 추가하고 싶다.</br>이런 경우가 있을 겁니다. 이럴 경우엔 탐색을 통해 원하는 위치를 찾고 그 위치에 새로운 노드를 추가해야 합니다.
       - 위 예제에서 2번째노드와 3번째 노드 사이에 추가한다고 가정해봅시다.</br> 우선 삽입할 위치를 찾는 노드 cur가 필요합니다. 위 두가지 경우에선 head,tail과 같은 위치를 담고 있는 노드가 있었지만 이번 경우엔 직접 설정해야만 합니다.!
       - 탐색을 통해 cur노드가 4를 가리키게 만듭니다.</br>새로운 노드 5가 가리키는 주소 --> cur이 가리키는 노드 4가 가르키는 다음 노드</br>cur이 가르키는 노드 4가 가르키는 다음노드 --> 새로운 노드 5
       - ![](https://t1.daumcdn.net/cfile/tistory/9948F4335A02BA5313)
   - 삭제
     - 노드의 삭제는 '원하는 자리에 삽입' 하는 과정과 유사합니다.
     - 그러나 삭제할 노드 전과 삭제할 노드의 후를 연결해줘야 하기 때문에 또 하나의 노드가 필요합니다.</br>이 노드를 pre라고 표현하겠습니다.
     - ![](https://t1.daumcdn.net/cfile/tistory/99EC52335A02BEF72C)
     - 탐색을 통해 삭제할 노드를 cur이 가르키게 하고, 삭제할 노드의 바로 전 노드를 pre가 가르키게 합니다.</br>pre가 가르키는 노드의 다음 주소 --> cur이 가리키는 다음주소</br>cur이 가리키는 노드를 free합니다.
4. __<span style="color:#ff9933">종류</span>__
   - 단순 연결 리스트
     - 단방향 링크 이전 노드에 접근하기 위해선 천번 쨰 노드부터 다시 순회해야함
     - ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbg1RBL%2FbtqHjqbPeYO%2FBdhc9SKnuuaFKbDwytBqk1%2Fimg.png)
   - 원형 연결 리스트
     - 단방향 링크
     - 마지막 노드와 첫 번째 노드가 연결된 원형 구조
     - 이전 노드에 접근하기 위해서 계속 한 방향으로만 순회하면됨
     - ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fu4AOA%2FbtqG9S1Wbpe%2FgQEg2IW5kJ9rUScTpYeeGK%2Fimg.png)
   - 이중 연결 리스트
     - 양방향 링크
     - 각 노드가 앞뒤로 연결됨
     - 이전 노드에 직접 접근가능
     - ![](https://t1.daumcdn.net/cfile/tistory/232CB93657394A7A22)