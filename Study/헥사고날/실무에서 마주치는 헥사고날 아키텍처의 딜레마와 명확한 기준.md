
# 헥사고날 아키텍처 실무 적용 가이드

## 1. 아키텍처 대원칙: 의존성 규칙 (The Dependency Rule)

- **원칙:** 모든 의존성은 **바깥쪽(인프라, 웹)에서 안쪽(도메인)**으로만 향해야 한다.
    
- **도메인의 순수성:** 도메인 계층은 바깥쪽(DB가 무엇인지, API가 REST인지, 프레임워크가 Spring인지)을 전혀 몰라야 한다.

### 실수하기 쉬운 위반 사례

1. **도메인 객체에 `@Component`, `@Entity` 사용:** 도메인은 POJO여야 한다. 프레임워크 의존성을 제거하라.
    
2. **Utils 클래스에서의 네트워크 호출:** `NamespaceUtils.validate()` 내부에서 K8s API를 호출하면 안 된다. 이는 순수 로직이 아니며, 테스트를 불가능하게 만든다. 반드시 **Port(인터페이스)**를 통해 주입받아 처리해야 한다.
    

---

## 2. 어댑터(Adapter)의 책임: "조립과 번역"

어댑터는 단순한 DB 접근자가 아닙니다. **"기술적인 현실(DB 구조)"을 "도메인의 이상(객체)"으로 번역**하는 번역가입니다.

###  Q1. 데이터를 조립(Aggregation)하는 건 누구 책임인가?

기준은 **애그리게이트(Aggregate)의 경계**입니다.

- **Case A: 같은 애그리게이트 (내 식구)**
    
    - **예시:** `Role` + `Permission` (역할 생성 시 권한 필수, 라이프사이클 동일)
        
    - **해결:** **어댑터가 조립합니다.**
        
    - `RoleRepository`에서 Join을 쓰든, 두 번 쿼리하든 해서 **완성된 `Role` 객체**를 리턴해야 합니다. 도메인 입장에서 `Role`은 권한을 가진 온전한 객체여야 하기 때문입니다.
        
- **Case B: 다른 애그리게이트 (남의 식구)**
    
    - **예시:** `Role` + `Member` (역할 조회 시 멤버 목록도 필요)
        
    - **해결:** **어플리케이션(Service)이 조립합니다.**
        
    - 데이터 양(페이징) 문제와 라이프사이클의 독립성 때문에, `RolePort`와 `MemberPort`를 각각 호출하여 서비스 계층에서 DTO로 합치는 것이 맞습니다.
        

###  Q2. 도메인이 DB 구조를 알아야 하는가?

- **절대 몰라야 합니다.**
    
- DB에 N:M 매핑 테이블(`role_permission`)이 있다고 해서, 도메인에 `RolePermission` 클래스를 만들 필요는 없습니다.
    
- 도메인은 `Role` 내부에 `List<PermissionId>`를 가지면 되고, 어댑터가 저장할 때 알아서 테이블을 쪼개서 넣어야 합니다.
    

---

## 3. 도메인 모델링: "ID 참조 vs 객체 참조"

DDD에서는 애그리게이트 간의 결합도를 낮추기 위해 **ID 참조**를 권장하지만, 상황에 따라 유연하게 적용합니다.

###  기준: 독립적인 관리 주체가 있는가?

- **독립적인 애그리게이트 (`PermissionDomain`이 별도 관리됨)**
    
    - 관리자 페이지에서 따로 등록/수정되고, 다른 도메인에서도 가져다 쓰는 경우.
        
    - **설계:** `Permission`은 **`domainId` (ID)**만 가집니다.
        
    - **검증:** 생성 시 서비스 계층에서 `existsById`로 유효성을 검증합니다.
        
- **단순 참조 데이터/Value Object (`PermissionDomain`이 단순 분류 코드임)**
    
    - 변경이 거의 없고, `Permission`의 부속품처럼 쓰이는 경우.
        
    - **설계:** `Permission`은 **`PermissionDomain` (객체)**을 직접 가집니다.
        
    - **이점:** 개발 시 `permission.domain.name` 처럼 직관적으로 사용할 수 있습니다. (어댑터가 조립해서 넣어줌)
        

---

## 4. 어플리케이션 서비스(UseCase)의 책임: "조율과 정책"

서비스 계층은 비즈니스의 **"절차(Flow)"**와 **"규칙(Rule)"**을 관장합니다.

###  삭제 로직의 구현 (Delete Orchestration)

"역할을 삭제한다"는 요구사항이 있을 때, 단순히 DB `DELETE`만 날리는 것이 아닙니다.

1. **남의 식구 정리 (Member):** "이 역할을 가진 멤버들의 매핑을 해제하라" (`memberPort.revokeRole`)
    
2. **내 식구 정리 (Role):** "역할과 권한 매핑을 삭제하라" (`rolePort.delete`)
    

이 **순서와 정책**을 관리하는 것이 어플리케이션 서비스의 역할입니다. 어댑터 하나에서 다른 도메인의 테이블까지 건드리면 결합도가 높아져 유지보수가 힘들어집니다.


---

## 요약: "누가 무엇을 아는가?"

| **계층**          | **역할**      | **아는 것 (Knowledge)**       | **모르는 것 (Ignorance)**    |
| --------------- | ----------- | -------------------------- | ------------------------ |
| **Domain**      | 비즈니스 로직의 핵심 | 자신의 속성, 행위, 규칙             | DB 테이블 구조, 프레임워크, API 명세 |
| **Adapter**     | 번역 및 데이터 접근 | DB 테이블 구조, SQL, 외부 API 사용법 | 비즈니스의 복잡한 처리 순서          |
| **Application** | 업무 흐름 조율    | 업무 처리 순서, 타 도메인과의 협력 방식    | SQL 쿼리, 데이터가 어떻게 저장되는지   |
